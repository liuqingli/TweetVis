<!DOCTYPE html>
<meta charset="utf-8">

<!-- CSS Style Type -->
<style type="text/css">
#MainContainer {
	width: 100%;
	margin: 0 auto;
	background: #EEE;
	position: relative;
}

#LeftContainer {
	width: 53%;
	margin-top: 0 auto;
	background: #EEE;
	float: left;
	position: relative;
}

#GeoGraph {
	margin: 1px;
	background: #FFF;
}

#TweetCountBar {
	width: 15px;
	margin-left: 95%;
	margin-top: 40%;
	position: absolute;
}

#TimeChart {
	margin: 1px;
	background: #FFF;
}

#RightContainer {
	width: 46.5%;
	margin-left: 5px;
	background: #EEE;
	float: left;
	position: relative;
}

#WordCloud {
	margin: 1px;
	padding-top:10px;
	background: #FFF;
}

#WordCountBar {
	margin: 1px;
	background: #FFF;
}

.states {
	fill: teal;
	fill-opacity: 0.7;
	stroke: #FFF;
	stroke-width: 1px;
}

path:hover {
	fill-opacity: 0.9;
	transition: all 0.5s;
}

div.tooltip {   
	position: absolute;           
	text-align: center;           
	width: 60px;                  
	height: 28px;                 
	padding: 2px;             
	font: 12px sans-serif;        
	background: white;   
	border: 0px;      
	border-radius: 8px;           
	pointer-events: none;         
}

.area {
	fill: teal;
	clip-path: url(#clip);
}

.zoom {
	cursor: move;
	fill: none;
	pointer-events: all;
}

/* WordCountBar CSS */
.bar {
  fill: teal;
}

.bar:hover {
  fill: orange;
}

.wordcountbar_axis_x text{
  fill: teal;
}

.wordcountbar_axis_x line{
  stroke: teal;
}

.wordcountbar_axis_x path{
  stroke: teal;
}  

.wordcountbar_axis_y text{
  fill: teal;
}

.wordcountbar_axis_y line{
  stroke: teal;
} 

.wordcountbar_axis_y path{
  stroke: teal;
}  

</style>

<!-- Main Body -->
<body>

	<!-- Import JavaScript Library -->
	<script src="//d3js.org/d3.v3.js"></script>
	<script src="//d3js.org/d3.v4.js"></script>
	<script src="//d3js.org/topojson.v1.min.js"></script>
	<script src="d3.layout.cloud.js"></script>
	
	<!-- Global Layout-->
	<div id="MainContainer">
		<!-- LeftContainer includes GeoGraph and TimeChart-->
		<div id="LeftContainer">	
			<div id="GeoGraph">
				<div id="TweetCountBar"></div>
			</div>
			<div id="TimeChart"></div>
		</div>
		<div id="RightContainer">
			<div id="WordCloud"></div>
			<div id="WordCountBar"></div>
		</div>
	</div>
	
	<script>
	
	/////////////////////////////////////////////////////////////////////////// 
	//                         GeoGraph Visualization                        //
	///////////////////////////////////////////////////////////////////////////
	var geo_width = 750, geo_height = 450;

	var projection = d3.geo.albersUsa()
	.scale(900)
	.translate([geo_width / 2 - 20, geo_height / 2]);

	var path = d3.geo.path()
	.projection(projection);

	var geograph = d3.select("#GeoGraph").append("svg")
	.attr("width", geo_width)
	.attr("height", geo_height);

	// Create the color set
	var color = d3.scale.linear()
	.range(['teal','rgb(69,60,100)','rgb(84,36,55)','rgb(157,31,37)']);

	// Load statetweets data
	d3.csv('statestweets.csv', function(data) {
		// Set the range of the input data
		color.domain([0,1,2,3]); 

		// Load GeoJSON data
		d3.json('us.json', function (error, us) {

			for (var i = 0; i < data.length; i++) {
				// Get state name from statetweets data 
				var dataStateName = data[i].state;
				// Get tweet number from each state  
				var dataTweetCount = data[i].count;

				// Find the corresponding state inside the GeoJSON
				for (var j = 0; j < topojson.feature(us, us.objects.usStates).features.length; j++)  {
					var jsonStateName = topojson.feature(us, us.objects.usStates).features[j].properties.STATE_ABBR;
					if (dataStateName == jsonStateName) {
						// Copy the data value into the JSON
						topojson.feature(us, us.objects.usStates).features[j].properties.count = dataTweetCount; 
						break;
					}
				}
			}
	
			// Draw with different colors
			geograph.selectAll('.states')
			.data(topojson.feature(us, us.objects.usStates).features)
			.enter()
			.append('path')
			.attr('class', 'states')
			.attr('d', path)
			.style('fill', function(d) {
				var count = d.properties.count;
				if (count) {
					return color(count);
				} else {
					return "teal";
				}
			});
		});

	});

	/////////////////////////////////////////////////////////////////////////// 
	//                       TweetCountBar Visualization                     //
	///////////////////////////////////////////////////////////////////////////
	var tweetcountbar_width = 15, tweetcountbar_height = 150;

	var tweetcountbar = d3.select("#TweetCountBar").append("svg")
	.attr("width", tweetcountbar_width)
	.attr("height", tweetcountbar_height);

	//Append a defs (for definition) element to your SVG
	var tweetcountbar_defs = tweetcountbar.append("defs");

	//Append a linearGradient element to the defs and give it a unique id
	var linearGradient = tweetcountbar_defs.append("linearGradient")
	.attr("id", "linear-gradient")
	.attr("x1", "0%")
	.attr("y1", "0%")
	.attr("x2", "0%")
	.attr("y2", "100%");

	linearGradient.append("stop") 
	.attr("offset", "0%")   
	.attr("stop-color", 'rgb(217,91,67)'); //light blue

	linearGradient.append("stop") 
	.attr("offset", "100%")   
	.attr("stop-color", "teal"); //dark blue

	tweetcountbar.append("rect")
	.attr("width", tweetcountbar_width)
	.attr("height", tweetcountbar_height)
	.style("fill", "url(#linear-gradient)");


	/////////////////////////////////////////////////////////////////////////// 
	//                         TimeChart Visualization                       //
	///////////////////////////////////////////////////////////////////////////
	var time_width = 720, time_height = 130;

	var timechart = d3.select("#TimeChart").append("svg")
	.attr("width", time_width)
	.attr("height", time_height);

	var margin = {top: 10, right: 25, bottom: 60, left: 35},
	margin2 = {top: 90, right: 25, bottom: 20, left: 35},
	time_width = +timechart.attr("width") - margin.left - margin.right,
	time_height = +timechart.attr("height") - margin.top - margin.bottom,
	time_height2 = +timechart.attr("height") - margin2.top - margin2.bottom;

	// Set up a date parsing function
	var parseDate = d3.time.format("%Y-%m-%d %H:%M:%S").parse;

	var x = d3.scaleTime().range([0, time_width]),
	x2 = d3.scaleTime().range([0, time_width]),
	y = d3.scaleLinear().range([time_height, 0]),
	y2 = d3.scaleLinear().range([time_height2, 0]);

	var xAxis = d3.axisBottom(x),
	xAxis2 = d3.axisBottom(x2),
	yAxis = d3.axisLeft(y).ticks(4);

	var brush = d3.brushX()
	.extent([[0, 0], [time_width, time_height2]])
	.on("brush end", brushed);

	var zoom = d3.zoom()
	.scaleExtent([1, 50])
	.translateExtent([[0, 0], [time_width, time_height]])
	.extent([[0, 0], [time_width, time_height]])
	.on("zoom", zoomed);

	var area = d3.area()
	.curve(d3.curveMonotoneX)
	.x(function (d) {
		return x(d.date);
	})
	.y0(time_height)
	.y1(function (d) {
		return y(d.count);
	});

	var area2 = d3.area()
	.curve(d3.curveMonotoneX)
	.x(function (d) {
		return x2(d.date);
	})
	.y0(time_height2)
	.y1(function (d) {
		return y2(d.count);
	});

	timechart.append("defs").append("clipPath")
	.attr("id", "clip")
	.append("rect")
	.attr("width", time_width)
	.attr("height", time_height);

	var focus = timechart.append("g")
	.attr("class", "focus")
	.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

	var context = timechart.append("g")
	.attr("class", "context")
	.attr("transform", "translate(" + margin2.left + "," + margin2.top + ")");

	d3.json("db_gettime.php", function (error, data) {
		data.forEach(function (d) {
			d.date = parseDate(d.date);
			d.count = +d.count;
		});

		x.domain(d3.extent(data, function (d) {
			return d.date;
		}));
		y.domain(d3.extent(data, function (d) {
			return d.count;
		}));
		x2.domain(x.domain());
		y2.domain(y.domain());

		focus.append("path")
		.datum(data)
		.attr("class", "area")
		.attr("d", area);

		focus.append("g")
		.attr("class", "axis axis--x")
		.attr("transform", "translate(0," + time_height + ")")
		.call(xAxis);

		focus.append("g")
		.attr("class", "axis axis--y")
		.call(yAxis);

		context.append("path")
		.datum(data)
		.attr("class", "area")
		.attr("d", area2);

		context.append("g")
		.attr("class", "axis axis--x")
		.attr("transform", "translate(0," + time_height2 + ")")
		.call(xAxis2);

		context.append("g")
		.attr("class", "brush")
		.call(brush)
		.call(brush.move, x.range());

		timechart.append("rect")
		.attr("class", "zoom")
		.attr("width", time_width)
		.attr("height", time_height)
		.attr("transform", "translate(" + margin.left + "," + margin.top + ")")
		.call(zoom);
	});

	function brushed() {
		if (d3.event.sourceEvent && d3.event.sourceEvent.type === "zoom") return;
		var s = d3.event.selection || x2.range();
		x.domain(s.map(x2.invert, x2));
		focus.select(".area").attr("d", area);
		focus.select(".axis--x").call(xAxis);
		timechart.select(".zoom").call(zoom.transform, d3.zoomIdentity
			.scale(time_width / (s[1] - s[0]))
			.translate(-s[0], 0));
		update_map();
	}

	function zoomed() {
		if (d3.event.sourceEvent && d3.event.sourceEvent.type === "brush") return;
		var t = d3.event.transform;
		x.domain(t.rescaleX(x2).domain());
		focus.select(".area").attr("d", area);
		focus.select(".axis--x").call(xAxis);
		context.select(".brush").call(brush.move, x.range().map(t.invertX, t));
		update_map();
	}
	
	//TODO add parameter and optimization
	function update_map() {
		geograph.selectAll("path").remove();
		d3.csv('statestweets.php', function(data) {
		// Set the range of the input data
		color.domain([0,1,2,3]); 
		// Load GeoJSON data
		d3.json('us.json', function (error, us) {
			for (var i = 0; i < data.length; i++) {
				// Get state name from statetweets data 
				var dataStateName = data[i].state;
				// Get tweet number from each state  
				var dataTweetCount = data[i].count;
				// Find the corresponding state inside the GeoJSON
				for (var j = 0; j < topojson.feature(us, us.objects.usStates).features.length; j++)  {
					var jsonStateName = topojson.feature(us, us.objects.usStates).features[j].properties.STATE_ABBR;
					if (dataStateName == jsonStateName) {
						// Copy the data value into the JSON
						topojson.feature(us, us.objects.usStates).features[j].properties.count = dataTweetCount; 
						break;
					}
				}
			}
	
			// Draw with different colors
			geograph.selectAll('.states')
			.data(topojson.feature(us, us.objects.usStates).features)
			.enter()
			.append('path')
			.attr('class', 'states')
			.attr('d', path)
			.style('fill', function(d) {
				var count = d.properties.count;
				if (count) {
					return color(count);
				} else {
					return "teal";
				}
			});
		});
		});
	}

	
	/////////////////////////////////////////////////////////////////////////// 
	//                         WordCloud Visualization                       //
	///////////////////////////////////////////////////////////////////////////
	d3.json("db_gettext.php", function (error, data) {
		var tweetString = "";
		data.forEach(function (d) {
			tweetString += d.text.replace(/[!\.,:;\?]/g, '').toLowerCase() + " ";
		});
		
		var wordArray = tweetString.split(" ");
		var wordObjects = [];
		
		function isNumeric(n) {
		  return !isNaN(parseFloat(n)) && isFinite(n);
		}
		
		var re = /^#\w+$/;
		wordArray.forEach(function(d) {
		    if (d.match(re)) {
				if(!isNumeric(d.replace("#",""))) {
					var wordObject = {}
					wordObject.word = d.replace("#", "");
					wordObjects.push(wordObject);
				}
			}
		});
		
		console.log(wordObjects);
		
		var wordCount = d3.nest()
		.key(function(d) { return d.word; })
	    .rollup(function(v) { return v.length; })
	    .entries(wordObjects);
		
		wordCount.sort(function(a, b) {
			return b.value - a.value;
		});
		
		wordCount = wordCount.slice(0,50)
		
		console.log(wordCount)
				
		var fill = d3.scale.category20();
		
		var wordcloud_width = 630, wordcloud_height = 150;
		
		var wordcloud = d3.select("#WordCloud").append("svg")
		.attr("width", wordcloud_width)
		.attr("height", wordcloud_height)
		.append("g")
		.attr("transform", "translate(" + (wordcloud_width / 2) + "," + (wordcloud_height / 2) + ")")
		
		var fontScale = d3.scale.linear().range([10, 60]);
		fontScale.domain([
			d3.min(wordCount, function(d) {
				return d.value
			}),
			d3.max(wordCount, function(d) {
				return d.value
			}),
		]);
		
		d3.layout.cloud().size([wordcloud_width, wordcloud_height])
		.words(wordCount)
		.rotate(0)
		.text(function(d) {
			return d.key;
		})        
		.font("Impact")
		.fontSize(function(d) {
			return fontScale(d.value)
		})
		.on("end", draw)
		.start();
		
		function draw(words) {
			var selectVis = wordcloud.selectAll("text")
			.data(words);
			
			selectVis
			.enter().append("text")
			.style("font-size", function(d) {
				return fontScale(d.value)
			})
			.style("font-family", "Impact")
			.style("fill", function(d, i) {
				return fill(i);
			})
			.attr("text-anchor", "middle")
			.attr("transform", function(d) {
				return "translate(" + [d.x, d.y] + ")rotate(" + d.rotate + ")";
			})
			.text(function(d) {
				return d.key;
			})
			
			selectVis
			.transition()
			.duration(600)
			.style("font-size", function(d) {
				return fontScale(d.value)
			})
			.attr("transform", function(d) {
				return "translate(" + [d.x, d.y] + ")rotate(" + d.rotate + ")";
			})
			.style("fill-opacity", 1);
		}
		
		/////////////////////////////////////////////////////////////////////////// 
		//                      WordCountBar Visualization                       //
		///////////////////////////////////////////////////////////////////////////
		
		wordCount = wordCount.slice(0,10)
		
		var setup = function(targetID){
			//Set size of svg element and chart
			var wcmargin = {top: 5, right: 10, bottom: 5, left: 10},
			wcbar_width = 625 - wcmargin.left - wcmargin.right,
			wcbar_height = 200 - wcmargin.top - wcmargin.bottom,
			wccategoryIndent = 60,
			wcdefaultBarWidth = 625;
			
			//Set up scales
			var wcbar_x = d3.scale.linear().domain([0,wcdefaultBarWidth]).range([0,wcbar_width]);
			var wcbar_y = d3.scale.ordinal().rangeRoundBands([0, wcbar_height], 0.2, 0);
			
			//Create SVG element
			var wordcountbar = d3.select(targetID).append("svg")
			.attr("width", wcbar_width + wcmargin.left + wcmargin.right)
			.attr("height", wcbar_height + wcmargin.top + wcmargin.bottom)
			.append("g")
			.attr("transform", "translate(" + wcmargin.left + "," + wcmargin.top + ")");
			
			//Package and export settings
			var settings = {
				wcmargin: wcmargin, wcbar_width: wcbar_width, 
				wcbar_height: wcbar_height, wccategoryIndent: wccategoryIndent,
				wordcountbar: wordcountbar, wcbar_x: wcbar_x, wcbar_y: wcbar_y
			}
			return settings;
		}

		var redraw_wordcountbar = function(targetID, newdata) {
			//Import settings
			var wcmargin = settings.wcmargin, 
			wcbar_width = settings.wcbar_width, 
			wcbar_height = settings.wcbar_height,
			wccategoryIndent = settings.wccategoryIndent, 
			wordcountbar = settings.wordcountbar, 
			wcbar_x = settings.wcbar_x, 
			wcbar_y = settings.wcbar_y;
			
			//Reset domains
			wcbar_y.domain(newdata.sort(function(a, b){
				return b.value - a.value;
			})
			.map(function(d) { return d.key; }));
			
			var wcbar_max = d3.max(newdata, function(e) {
				return e.value;
			});
			wcbar_x.domain([0, wcbar_max]);

			// Enter Process                     //
			///////////////////////////////////////

			//Create chart row and move to below the bottom of the chart
			var chartRow = wordcountbar.selectAll("g.chartRow")
			.data(newdata, function(d){ return d.key});
			
			var newRow = chartRow
			.enter().append("g")
			.attr("class", "chartRow")
			.attr("transform", "translate(0," + wcbar_height + wcmargin.top + wcmargin.bottom + ")");

			//Add rectangles
			newRow.insert("rect")
			.attr("class", "bar")
			.attr("x", 0)
			.attr("opacity",0.5)
			.style("fill", function(d, i) {
				return fill(i);
			})
			.attr("height", wcbar_y.rangeBand())
			.attr("width", function(d) { return wcbar_x(d.value);}) 

			//Add value labels
			newRow.append("text")
			.attr("class", "label")
			.attr("y", wcbar_y.rangeBand()/2)
			.attr("x",0)
			.attr("opacity",1)
			.attr("font-size", "14px")
			.attr("font-family", "Verdana")
			.attr("dy",".3em")
			.attr("dx",".5em")
			.style("fill", "#777")
			.text(function(d) { return d.value; }); 
	
			//Add Headlines
			newRow.append("text")
			.attr("class", "category")
			.attr("text-overflow","ellipsis")
			.attr("y", wcbar_y.rangeBand()/2)
			.attr("x", wccategoryIndent)
			.attr("opacity",1)
			.attr("font-size", "14px")
			.attr("font-family", "Verdana")
			.attr("dy",".3em")
			.attr("dx",".5em")
			.style("fill", "#777")
			.text(function(d) {return d.key});

			// Update Process                    //
			///////////////////////////////////////
	
			//Update bar widths
			chartRow.select(".bar").transition()
			.duration(300)
			.attr("width", function(d) { return wcbar_x(d.value);})
			.attr("opacity", 0.5)
			.style("fill", function(d, i) {
				return fill(i);
			});

			//Update data labels
			chartRow.select(".label").transition()
			.duration(300)
			.attr("opacity", 1)
			.tween("text", function(d) { 
				var i = d3.interpolate( +this.textContent.replace(/\,/g,''), + d.value);
				return function(t) {
					this.textContent = Math.round(i(t));
				};
			});

			//Fade in categories
			chartRow.select(".category").transition()
			.duration(300)
			.attr("opacity", 1);

			// Exit Process                      //
			///////////////////////////////////////

			//Fade out and remove exit elements
			chartRow.exit().transition()
			.style("opacity","0")
			.attr("transform", "translate(0," + (wcbar_height + wcmargin.top + wcmargin.bottom) + ")")
			.remove();

			// Reorder Process                      //
			///////////////////////////////////////
			var delay = function(d, i) { return 200 + i * 30; };
			chartRow.transition()
			.delay(delay)
			.duration(900)
			.attr("transform", function(d) { return "translate(0," + wcbar_y(d.key) + ")"; });
		};

		//Pulls data
		//Since our data is fake, adds some random changes to simulate a data stream.
		//Uses a callback because d3.json loading is asynchronous
		var pullData = function(settings, callback){
			var newData = wordCount;
			newData.forEach(function(d,i){
				var newValue = d.value + Math.floor((Math.random()*100) - 5)
				d.value = newValue <= 0 ? 10 : newValue
			})
			newData = formatData(newData);
			callback(settings, newData);
		};

		//Sort data in descending order and take the top 10 values
		var formatData = function(data){
			return data.sort(function (a, b) {
				return b.value - a.value;
			})
			.slice(0, 10);
		}
		
		var redraw = function(settings){
			pullData(settings, redraw_wordcountbar)
		}

		var settings = setup("#WordCountBar");
		redraw(settings);
		
		//Repeat every 20 seconds
		setInterval(function(){redraw(settings)}, 3000);
	});
	</script>
</body>