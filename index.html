<!DOCTYPE html>
<meta charset="utf-8">

<!-- CSS Style Type -->
<style type="text/css">
#MainContainer {
	width: 100%;
	margin: 0 auto;
	background: #AAA;
	position: relative;
}

#LeftContainer {
	width: 53%;
	margin-top: 0 auto;
	background: #EEE;
	float: left;
	position: relative;
}

#GeoGraph {
	margin: 1px;
	background: #FFF;
}

#TweetCountBar {
	width: 15px;
	margin-left: 95%;
	margin-top: 40%;
	position: absolute;
}

#TimeChart {
	margin: 1px;
	background: #FFF;
}

#RightContainer {
	width: 46.5%;
	margin-left: 5px;
	background: #EEE;
	float: left;
	position: relative;
}

#WordCloud {
	margin: 1px;
	padding-top:10px;
	background: #FFF;
}

#WordCountBar {
	margin: 1px;
	background: #FFF;
}

/* Network CSS */
#Network {
	margin: 1px;
	background: #FFF;
}

.links line {
  stroke: #999;
  stroke-opacity: 0.6;
}

.nodes circle {
  stroke: #fff;
  stroke-width: 1.5px;
}

/* RawText CSS */
#RawText {
	margin: 1px;
	background: #FFF;
	overflow-y: auto;
	background-color: #EEE;
	border: 1px solid #FFF;
	border-radius: 4px;
	box-shadow: inset 1px 1px 10px 2px rgba(0, 128, 128, .25);
}

/* Other CSS */

.states {
	fill: teal;
	fill-opacity: 0.7;
	stroke: #FFF;
	stroke-width: 1px;
}

path:hover {
	fill-opacity: 1.0;
	transition: all 0.5s;
}

div.tooltip {   
	position: absolute;           
	text-align: center;           
	width: 60px;                  
	height: 28px;                 
	padding: 2px;             
	font: 12px sans-serif;        
	background: white;   
	border: 0px;      
	border-radius: 8px;           
	pointer-events: none;         
}

.area {
	fill: teal;
	clip-path: url(#clip);
}

.zoom {
	cursor: move;
	fill: none;
	pointer-events: all;
}

/* WordCountBar CSS */

.bar {
  fill: teal;
}

.bar:hover {
  fill: orange;
}

.wordcountbar_axis_x text{
  fill: teal;
}

.wordcountbar_axis_x line{
  stroke: teal;
}

.wordcountbar_axis_x path{
  stroke: teal;
}  

.wordcountbar_axis_y text{
  fill: teal;
}

.wordcountbar_axis_y line{
  stroke: teal;
} 

.wordcountbar_axis_y path{
  stroke: teal;
}

</style>

<!-- Main Body -->
<body>

	<!-- Import JavaScript Library -->
	<script src="//d3js.org/d3.v3.js"></script>
	<script src="//d3js.org/d3.v4.js"></script>
	<script src="//d3js.org/d3-color.v1.min.js"></script>
	<script src="//d3js.org/topojson.v1.min.js"></script>
	<script src="//npmcdn.com/babel-core@5.8.34/browser.min.js"></script>
	<script src="d3.layout.cloud.js"></script>
	
	<!-- Global Layout-->
	<div id="MainContainer">
		<!-- LeftContainer includes GeoGraph and TimeChart-->
		<div id="LeftContainer">	
			<div id="GeoGraph">
				<div id="TweetCountBar"></div>
			</div>
			<div id="TimeChart"></div>
		</div>
		<div id="RightContainer">
			<div id="WordCloud"></div>
			<div id="WordCountBar"></div>
			<div id="Network"></div>
			<div id="RawText"></div>
		</div>
	</div>
	
	<script>
	
	var time_width = 720, time_height = 130;
	var timechart = d3.select("#TimeChart").append("svg")
	.attr("width", time_width)
	.attr("height", time_height);
	
	var geo_width = 750, geo_height = 450;
	var geograph = d3.select("#GeoGraph").append("svg")
	.attr("width", geo_width)
	.attr("height", geo_height);
	
	//Set size of svg element and chart
	var wcmargin = {top: 5, right: 10, bottom: 5, left: 10},
	wcbar_width = 625 - wcmargin.left - wcmargin.right,
	wcbar_height = 200 - wcmargin.top - wcmargin.bottom,
	wccategoryIndent = 60,
	wcdefaultBarWidth = 625;

	//Set up scales
	var wcbar_x = d3.scale.linear().domain([0,wcdefaultBarWidth]).range([0,wcbar_width]);
	var wcbar_y = d3.scale.ordinal().rangeRoundBands([0, wcbar_height], 0.2, 0);

	//Create SVG element
	var wordcountbar = d3.select("#WordCountBar").append("svg")
	.attr("width", wcbar_width + wcmargin.left + wcmargin.right)
	.attr("height", wcbar_height + wcmargin.top + wcmargin.bottom)
	.append("g")
	.attr("transform", "translate(" + wcmargin.left + "," + wcmargin.top + ")");
	
	/////////////////////////////////////////////////////////////////////////// 
	//                         GeoGraph Visualization                        //
	///////////////////////////////////////////////////////////////////////////
	
	var projection = d3.geo.albersUsa()
	.scale(900)
	.translate([geo_width / 2 - 20, geo_height / 2]);

	var path = d3.geo.path()
	.projection(projection);

	// Create the color set
	var color = d3.scale.linear()
	.range(['teal','rgb(69,60,100)','rgb(84,36,55)','rgb(157,31,37)']);

	update_map("","");

	/*
	/////////////////////////////////////////////////////////////////////////// 
	//                       TweetCountBar Visualization                     //
	///////////////////////////////////////////////////////////////////////////
	var tweetcountbar_width = 15, tweetcountbar_height = 150;

	var tweetcountbar = d3.select("#TweetCountBar").append("svg")
	.attr("width", tweetcountbar_width)
	.attr("height", tweetcountbar_height);

	//Append a defs (for definition) element to your SVG
	var tweetcountbar_defs = tweetcountbar.append("defs");

	//Append a linearGradient element to the defs and give it a unique id
	var linearGradient = tweetcountbar_defs.append("linearGradient")
	.attr("id", "linear-gradient")
	.attr("x1", "0%")
	.attr("y1", "0%")
	.attr("x2", "0%")
	.attr("y2", "100%");

	linearGradient.append("stop") 
	.attr("offset", "0%")   
	.attr("stop-color", 'rgb(217,91,67)'); //light blue

	linearGradient.append("stop") 
	.attr("offset", "100%")   
	.attr("stop-color", "teal"); //dark blue

	tweetcountbar.append("rect")
	.attr("width", tweetcountbar_width)
	.attr("height", tweetcountbar_height)
	.style("fill", "url(#linear-gradient)");
	*/


	/////////////////////////////////////////////////////////////////////////// 
	//                     TimeChart and Map Visualization                   //
	///////////////////////////////////////////////////////////////////////////
	var map_us;
	
	d3.json('us.json', function (error, us) {
		map_us = us;
	});

	var margin = {top: 10, right: 25, bottom: 60, left: 35},
	margin2 = {top: 90, right: 25, bottom: 20, left: 35},
	time_width = +timechart.attr("width") - margin.left - margin.right,
	time_height = +timechart.attr("height") - margin.top - margin.bottom,
	time_height2 = +timechart.attr("height") - margin2.top - margin2.bottom;

	// Set up a date parsing function
	var parseDate = d3.time.format("%Y-%m-%d %H:%M:%S").parse;

	var x = d3.scaleTime().range([0, time_width]),
	x2 = d3.scaleTime().range([0, time_width]),
	y = d3.scaleLinear().range([time_height, 0]),
	y2 = d3.scaleLinear().range([time_height2, 0]);

	var xAxis = d3.axisBottom(x),
	xAxis2 = d3.axisBottom(x2),
	yAxis = d3.axisLeft(y).ticks(4);

	var brush = d3.brushX()
	.extent([[0, 0], [time_width, time_height2]])
	.on("brush end", brushed);

	var zoom = d3.zoom()
	.scaleExtent([1, 50])
	.translateExtent([[0, 0], [time_width, time_height]])
	.extent([[0, 0], [time_width, time_height]])
	.on("zoom", zoomed)
	.on("end", zoomEnd);

	var area = d3.area()
	.curve(d3.curveMonotoneX)
	.x(function (d) {
		return x(d.date);
	})
	.y0(time_height)
	.y1(function (d) {
		return y(d.count);
	});

	var area2 = d3.area()
	.curve(d3.curveMonotoneX)
	.x(function (d) {
		return x2(d.date);
	})
	.y0(time_height2)
	.y1(function (d) {
		return y2(d.count);
	});

	timechart.append("defs").append("clipPath")
	.attr("id", "clip")
	.append("rect")
	.attr("width", time_width)
	.attr("height", time_height);

	var focus = timechart.append("g")
	.attr("class", "focus")
	.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

	var context = timechart.append("g")
	.attr("class", "context")
	.attr("transform", "translate(" + margin2.left + "," + margin2.top + ")");

	d3.json("db_gettime.php", function (error, data) {
		data.forEach(function (d) {
			d.date = parseDate(d.date);
			d.count = +d.count;
		});

		x.domain(d3.extent(data, function (d) {
			return d.date;
		}));
		y.domain(d3.extent(data, function (d) {
			return d.count;
		}));
		x2.domain(x.domain());
		y2.domain(y.domain());

		focus.append("path")
		.datum(data)
		.attr("class", "area")
		.attr("d", area);

		focus.append("g")
		.attr("class", "axis axis--x")
		.attr("transform", "translate(0," + time_height + ")")
		.call(xAxis);

		focus.append("g")
		.attr("class", "axis axis--y")
		.call(yAxis);

		context.append("path")
		.datum(data)
		.attr("class", "area")
		.attr("d", area2);

		context.append("g")
		.attr("class", "axis axis--x")
		.attr("transform", "translate(0," + time_height2 + ")")
		.call(xAxis2);

		context.append("g")
		.attr("class", "brush")
		.call(brush)
		.call(brush.move, x.range());

		timechart.append("rect")
		.attr("class", "zoom")
		.attr("width", time_width)
		.attr("height", time_height)
		.attr("transform", "translate(" + margin.left + "," + margin.top + ")")
		.call(zoom);
	});

	function brushed() {
		if (d3.event.sourceEvent && d3.event.sourceEvent.type === "zoom") return;
		var s = d3.event.selection || x2.range();
		x.domain(s.map(x2.invert, x2));
		focus.select(".area").attr("d", area);
		focus.select(".axis--x").call(xAxis);
		timechart.select(".zoom").call(zoom.transform, d3.zoomIdentity
			.scale(time_width / (s[1] - s[0]))
			.translate(-s[0], 0));
	}

	function zoomed() {
		if (d3.event.sourceEvent && d3.event.sourceEvent.type === "brush") return;
		var t = d3.event.transform;
		x.domain(t.rescaleX(x2).domain());
		focus.select(".area").attr("d", area);
		focus.select(".axis--x").call(xAxis);
		context.select(".brush").call(brush.move, x.range().map(t.invertX, t));
	}

	function zoomEnd()
	{
		if (d3.event.sourceEvent
			&& (d3.event.sourceEvent.type != "end")) return;
		//get date information and encode using base64
		var daterange = x.domain();
		var from_date = btoa(daterange[0]);
		var to_date = btoa(daterange[1]);
		update_map(from_date,to_date);
		update_network(from_date,to_date);
		update_word_cloud(from_date,to_date);
	}
	
	function update_map(from_date,to_date) {
		//construct uri
		var request_uri="statestweets.php?f="+from_date+"&t="+to_date;
		//and send request to server
		var state_count;
		d3.json(request_uri, function(data) {
			// Load GeoJSON data
			geograph.selectAll("path").remove();
			for (var i = 0; i < data.length; i++) {
				// Get state name from statetweets data 
				var dataStateName = data[i].state;
				// Get tweet number from each state  
				var dataTweetCount = data[i].count;
				// Find the corresponding state inside the GeoJSON
				for (var j = 0; j < topojson.feature(map_us, map_us.objects.usStates).features.length; j++)  {
					var jsonStateName = topojson.feature(map_us, map_us.objects.usStates).features[j].properties.STATE_ABBR;
					if (dataStateName == jsonStateName) {
						// Copy the data value into the JSON
						topojson.feature(map_us, map_us.objects.usStates).features[j].properties.count = dataTweetCount; 
						break;
					}
				}
			}
				
			// Draw with different colors
			geograph.selectAll('.states')
			.data(topojson.feature(map_us, map_us.objects.usStates).features)
			.enter()
			.append('path')
			.attr('class', 'states')
			.attr('d', path)
			.style('fill', function(d) {
				var count = d.properties.count;
				return color(count);
			});
		});
	}

	update_word_cloud("","");
	/////////////////////////////////////////////////////////////////////////// 
	//                         WordCloud Visualization                       //
	///////////////////////////////////////////////////////////////////////////
	function update_word_cloud(from_date,to_date) {
		var request_uri="db_gettext.php?f="+from_date+"&t="+to_date;
		d3.json(request_uri, function (error, data) {
			var tweetString = "";
			data.forEach(function (d) {
				tweetString += d.text.replace(/[!\.,:;\?]/g, '').toLowerCase() + " ";
			});
			
			var wordArray = tweetString.split(" ");
			var wordObjects = [];
			
			function isNumeric(n) {
			  return !isNaN(parseFloat(n)) && isFinite(n);
			}
			
			var re = /^#\w+$/;
			wordArray.forEach(function(d) {
			    if (d.match(re)) {
					if(!isNumeric(d.replace("#",""))) {
						var wordObject = {}
						wordObject.word = d.replace("#", "");
						wordObjects.push(wordObject);
					}
				}
			});
			
			//console.log(wordObjects);
			
			var wordCount = d3.nest()
			.key(function(d) { return d.word; })
		    .rollup(function(v) { return v.length; })
		    .entries(wordObjects);
			
			wordCount.sort(function(a, b) {
				return b.value - a.value;
			});
			
			wordCount = wordCount.slice(0,50)
			
			//console.log(wordCount)
					
			var fill = d3.scale.category20();
			
			var wordcloud_width = 630, wordcloud_height = 150;

			d3.select("#WordCloud").selectAll("*").remove();

			var wordcloud = d3.select("#WordCloud").append("svg")
			.attr("width", wordcloud_width)
			.attr("height", wordcloud_height)
			.append("g")
			.attr("transform", "translate(" + (wordcloud_width / 2) + "," + (wordcloud_height / 2) + ")")
			
			var fontScale = d3.scale.linear().range([10, 60]);
			fontScale.domain([
				d3.min(wordCount, function(d) {
					return d.value
				}),
				d3.max(wordCount, function(d) {
					return d.value
				}),
			]);
			
			d3.layout.cloud().size([wordcloud_width, wordcloud_height])
			.words(wordCount)
			.rotate(0)
			.text(function(d) {
				return d.key;
			})        
			.font("Impact")
			.fontSize(function(d) {
				return fontScale(d.value)
			})
			.on("end", draw)
			.start();
			
			function draw(words) {
				var selectVis = wordcloud.selectAll("text")
				.data(words);
				
				selectVis
				.enter().append("text")
				.style("font-size", function(d) {
					return fontScale(d.value)
				})
				.style("font-family", "Impact")
				.style("fill", function(d, i) {
					return fill(i);
				})
				.attr("text-anchor", "middle")
				.attr("transform", function(d) {
					return "translate(" + [d.x, d.y] + ")rotate(" + d.rotate + ")";
				})
				.text(function(d) {
					return d.key;
				})
				
				selectVis
				.transition()
				.duration(600)
				.style("font-size", function(d) {
					return fontScale(d.value)
				})
				.attr("transform", function(d) {
					return "translate(" + [d.x, d.y] + ")rotate(" + d.rotate + ")";
				})
				.style("fill-opacity", 1);
			}
			
			/////////////////////////////////////////////////////////////////////////// 
			//                      WordCountBar Visualization                       //
			///////////////////////////////////////////////////////////////////////////
			wordCount = wordCount.slice(0,10);
						
			var redraw_wordcountbar = function(newdata) {
				//Reset domains
				wcbar_y.domain(newdata.sort(function(a, b){
					return b.value - a.value;
				})
				.map(function(d) { return d.key; }));
			
				var wcbar_max = d3.max(newdata, function(e) {
					return e.value;
				});
				wcbar_x.domain([0, wcbar_max]);

				// Enter Process                     //
				///////////////////////////////////////

				//Create chart row and move to below the bottom of the chart
				var chartRow = wordcountbar.selectAll("g.chartRow")
				.data(newdata, function(d){ return d.key});
			
				var newRow = chartRow
				.enter().append("g")
				.attr("class", "chartRow")
				.attr("transform", "translate(0," + wcbar_height + wcmargin.top + wcmargin.bottom + ")");

				//Add rectangles
				newRow.insert("rect")
				.attr("class", "bar")
				.attr("x", 0)
				.attr("opacity",0.5)
				.style("fill", function(d) {
					return d3.hsl(d.value, 100, 100);
				})
				.attr("height", wcbar_y.rangeBand())
				.attr("width", function(d) { return wcbar_x(d.value);}) 

				//Add value labels
				newRow.append("text")
				.attr("class", "label")
				.attr("y", wcbar_y.rangeBand()/2)
				.attr("x",0)
				.attr("opacity",1)
				.attr("font-size", "14px")
				.attr("font-family", "Verdana")
				.attr("dy",".3em")
				.attr("dx",".5em")
				.style("fill", "#777")
				.text(function(d) { return d.value; }); 
	
				//Add Headlines
				newRow.append("text")
				.attr("class", "category")
				.attr("text-overflow","ellipsis")
				.attr("y", wcbar_y.rangeBand()/2)
				.attr("x", wccategoryIndent)
				.attr("opacity",1)
				.attr("font-size", "14px")
				.attr("font-family", "Verdana")
				.attr("dy",".3em")
				.attr("dx",".5em")
				.style("fill", "#777")
				.text(function(d) {return d.key});

				// Update Process                    //
				///////////////////////////////////////
	
				//Update bar widths
				chartRow.select(".bar").transition()
				.duration(300)
				.attr("width", function(d) { return wcbar_x(d.value);})
				.attr("opacity", 0.5)
				.style("fill", function(d) {
					return d3.hsl(d.value, 100, 100);
				});

				//Update data labels
				chartRow.select(".label").transition()
				.duration(300)
				.attr("opacity", 1)
				.text(function(d) {return d.value});
				/*		
				.tween("text", function(d) { 
					var i = d3.interpolate( + this.textContent.replace(/\,/g,''), + d.value);
					return function(t) {
						this.textContent = Math.round(i(t));
					};
				});
				*/
				//Fade in categories
				chartRow.select(".category").transition()
				.duration(300)
				.text(function(d) {return d.key})
				.attr("opacity", 1);

				// Exit Process                      //
				///////////////////////////////////////

				//Fade out and remove exit elements
				chartRow.exit().transition()
				.style("opacity","0")
				.attr("transform", "translate(0," + (wcbar_height + wcmargin.top + wcmargin.bottom) + ")")
				.remove();

				// Reorder Process                      //
				///////////////////////////////////////
				var delay = function(d, i) { return 200 + i * 30; };
				chartRow.transition()
				.delay(delay)
				.duration(900)
				.attr("transform", function(d) { return "translate(0," + wcbar_y(d.key) + ")"; });
				
				wordcountbar
				.transition()
				.duration(600)
                .style("fill-opacity", 1);
				
				wordcountbar
				.exit()
				.transition()
				.duration(600)
                .style("fill-opacity", 0)
				.remove();
			};

			var pullData = function(callback){
				var newData = wordCount;
				newData = formatData(newData);
				callback(newData);
			};

			//Sort data in descending order and take the top 10 values
			var formatData = function(data){
				return data.sort(function (a, b) {
					return b.value - a.value;
				})
				.slice(0, 10);
			}
		
		
			var redraw = function(){
				pullData(redraw_wordcountbar)
			}
	
			pullData(redraw_wordcountbar);
			redraw();
		});
	}
	/////////////////////////////////////////////////////////////////////////// 
	//                          Network Visualization                        //
	///////////////////////////////////////////////////////////////////////////		
	var network_width = 630, network_height = 190;
		
	var color = d3.scaleOrdinal(d3.schemeCategory20);
	
	var simulation = d3.forceSimulation()
	.force("link", d3.forceLink().id(function(d) { return d.id; }))
	.force("charge", d3.forceManyBody())
    .force("center", d3.forceCenter( network_width / 2, network_height / 2))
//	.force('x', d3.forceX())
    .force('y', d3.forceY());

	update_network("","");

	function update_network(from_date,to_date)
	{
		//var request_uri="db_network.php?f="+from_date+"&t="+to_date;
		var request_uri="network.json";
		d3.json(request_uri, function(error, graph) {
			if (error) throw error;

			d3.select("#Network").selectAll("*").remove();
			var svg = d3.select("#Network").append("svg")
				.attr("width", network_width)
				.attr("height", network_height);

			var link = svg.append("g")
			.attr("class", "links")
			.selectAll("line")
			.data(graph.links)
			.enter().append("line")
			.attr("stroke-width", function(d) { return Math.sqrt(d.value); });
			
			var node = svg.append("g")
			.attr("class", "nodes")
			.selectAll("circle")
			.data(graph.nodes)
			.enter().append("circle")
			.attr("r", 5)
			.attr("fill", function(d) { return color(d.group); })
			.call(d3.drag()
			.on("start", dragstarted)
			.on("drag", dragged)
			.on("end", dragended));
			
			node.append("title").text(function(d) { return d.id; });
			
			simulation.nodes(graph.nodes).on("tick", ticked);
			simulation.force("link").links(graph.links);
			
			function ticked() {
				link
				.attr("x1", function(d) { return d.source.x; })
				.attr("y1", function(d) { return d.source.y; })
				.attr("x2", function(d) { return d.target.x; })
				.attr("y2", function(d) { return d.target.y; });
				
				node
				.attr("cx", function(d) { return d.x; })
				.attr("cy", function(d) { return d.y; });
			}
			simulation.restart();
		});
		
		function dragstarted(d) {
			if (!d3.event.active)
				simulation.alphaTarget(0.3).restart();
			d.fx = d.x;
			d.fy = d.y;
		}
		
		function dragged(d) {
			d.fx = d3.event.x;
			d.fy = d3.event.y;
		}
		
		function dragended(d) {
			if (!d3.event.active)
				simulation.alphaTarget(0);
			d.fx = null;
			d.fy = null;
		}
	}
	/////////////////////////////////////////////////////////////////////////// 
	//                          RawText Visualization                        //
	///////////////////////////////////////////////////////////////////////////		
	var rawtext_width = 630, rawtext_height = 20;
	
	var rawtext = d3.select("#RawText").append("svg")
	.attr("width", rawtext_width)
	.attr("height", rawtext_height);
	
	rawtext.append("text")
    .attr("x", 10)
    .attr("y", rawtext_height / 2)
	.attr("font-family", "sans-serif")
	.attr("font-size", "16px")
	.attr("fill", "teal")
    .attr("dy", ".45em")
    .text("Test");
	
	</script>
</body>
